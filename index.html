<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Project1: Images of the Russian Empire</title>
  <style>
    body {
      background-color: #D8C3DD; /* 紫色背景 */
      font-family: Arial, sans-serif;
      color: white;
      margin: 0;
      padding: 0;
    }
    /* 导航栏 */
    nav {
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 20px;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    nav a {
      color: #ffddff;
      text-decoration: none;
      margin: 0 15px;
      font-weight: bold;
    }
    nav a:hover {
      text-decoration: underline;
    }
    .container {
      width: 80%;
      margin: auto;
      padding: 20px;
    }
    h1 {
      text-align: center;
      margin-top: 20px;
    }
    .section {
      background: rgba(0,0,0,0.2);
      padding: 20px;
      margin: 40px 0;
      border-radius: 12px;
    }
    .section h2 {
      color: #ffddff;
      text-align: center;
    }
    img {
      max-width: 100%;
      border-radius: 8px;
    }
    .row {
      display: flex;
      justify-content: center;
      gap: 40px;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    .img-block {
      text-align: center;
    }
    .img-block p {
      margin-top: 8px;
      font-size: 16px;
    }
    p {
      text-align: left;
      max-width: 800px;
      margin: auto;
      margin-bottom: 20px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <!-- 导航栏 -->
  <nav>
    <a href="#part1">Part1</a>
    <a href="#part2">Part2</a>
    <a href="#part3">Part3</a>
    <a href="#part4">Part4</a>
  </nav>

  <div class="container">
    <h1>Project1: Images of the Russian Empire: Colorizing the Prokudin-Gorskii photo collection</h1>
    <p style="text-align:center; font-style:italic;">Freya Sun</p>

    <!-- Part1 -->
    <div class="section" id="part1">
      <h2>Part1: Single-scale alignment</h2>
      <h3>Method</h3>
      <p>
        For the exhaustive single-scale approach, I started by reading in the image and converting it to a double. 
        The pixel values are normalized and within [0,1]. I then split the image into three equal parts, each representing one color channel (blue, green, and red). 
        The blue channel is used as the reference channel. For each of the other two channels, I exhaustively search for the best alignment by shifting the channel within a specified range (-15 to +15 pixels in both x and y directions). 
        In each shift, I use np.roll to translate the moving channel and evaluate alignment only over the true overlapping region so wrapped pixels don’t bias the score. 
        For each possible shift, I calculated the image matching score between the shifted channel and the reference channel. I implemented both scoring metrics, the L2 norm/euclidean distance and the normalized cross-correlation. 
        The L2 norm is the default metric, but for emir.tif, since it has strong brightness differences across channels, I switched to NCC and aligned on edge features instead of raw intensities. 
        NCC is more robust in this case because edges are less affected by cross-channel brightness differences. 
        The shift that minimizes L2/euclidean distance (or maximizes NCC) is considered the best alignment. 
        After finding the optimal shifts for both the green and red channels, I combine them with the blue channel to create the final color image.
      </p>
      <h3>Results</h3>
      <div class="row">
        <div class="img-block">
          <img src="cathedral_out.jpg" alt="cathedral result" width="300">
          <p>cathedral<br>G (5,2), R (12,3)</p>
        </div>
        <div class="img-block">
          <img src="monastery_out.jpg" alt="monastery result" width="300">
          <p>cathedral<br>G (-3,2), R (3,2)</p>
        </div>
        <div class="img-block">
          <img src="tobolsk_out.jpg" alt="tobolsk result" width="300">
          <p>tobolsk<br>G (3,3), R (6,3)</p>
        </div>
      </div>
    </div>

    <!-- Part2 -->
    <div class="section" id="part2">
      <h2>Part2: Pyramid alignment</h2>
      <h3>Method</h3>
      <p>
        This part introduces the concept of an image pyramid to speed up the alignment process for larger images. 
        By creating a multi-scale representation of the images, we can perform alignment at a coarse scale and then refine it at finer scales. 
        This approach significantly reduces the computational cost while maintaining alignment accuracy.
      </p>
      <p>
        To be more specific, the image is first downsampled by a factor of 2 (with sk.transform.rescale) to create a lower-resolution version, repeatedly applying downsampling until the size is manageable for a exhaustive search. 
        A search in the lower-resolution space gives us a coarse shift for alignment, which allows us to initialize the finer alignment at a better position. 
        A finer search is then done starting at the coarsely shifted channels. Therefore, the total shift in this step will be coarse_shift * downsample_factor + fine_shift. 
        This final calculated shift will serve as the coarse shift for the next level of the pyramid. 
        The implementation of the method is done by a simple recursion, where the function first downsamples the channels, recurses and get the coarse shift with one fewer level, shifts the channels according to the coarse shift, searches for the fine shift, and finally returns the calculated shift based on both coarse and fine offsets. 
        The base case is when the passed in num_levels is 1, where a single-scale search is then done to find the shift at the most coarse level.
      </p>
      <p>
        The following images are the results of applying the image pyramid approach to the alignment task on the .tif files, which is much larger than the images in the previous part. 
        The search range is ±5 pixels with 6 levels of factor-of-2-downsampling. NCC is used for metric. About 10% cropping is done on each side for this part. 
        For the smaller .jpg images, the multi-scale search is still applied to demonstrate the effectiveness of the approach and fulfill the requirements of the project. 
        All the .jpg images are processed with a 3-level pyramid of factor 2 downsampling, the search range being ±5 pixels.
      </p>
      <h3>Results</h3>
      <div class="row">
        <div class="img-block"><img src="church_out.jpg" alt="church" height="180"><p>church<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="harvesters_out.jpg" alt="harvesters" height="180"><p>harvesters<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="emir_out.jpg" alt="emir" height="180"><p>emir<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="three_generations_out.jpg" alt="three generations" height="180"><p>three_generations<br>G (5,2), R (12,3)</p></div>
      </div>
      <div class="row">
        <div class="img-block"><img src="lastochikino_out.jpg" alt="lastochikino" height="180"><p>lastochikino<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="italil_out.jpg" alt="italil" height="180"><p>italil<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="icon_out.jpg" alt="icon" height="180"><p>icon<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="melons_out.jpg" alt="melons" height="180"><p>melons<br>G (5,2), R (12,3)</p></div>
      </div>
      <div class="row">
        <div class="img-block"><img src="lugano_out.jpg" alt="lugano" height="180"><p>lugano<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="self_portrait_out.jpg" alt="self portrait" height="180"><p>self_portrait<br>G (5,2), R (12,3)</p></div>
        <div class="img-block"><img src="siren_out.jpg" alt="siren" height="180"><p>siren<br>G (5,2), R (12,3)</p></div>
      </div>
    </div>

    <!-- Part3 -->
    <div class="section" id="part3">
      <h2>Part3: Results On My Own Images</h2>
      <!-- 等你补充 -->
    </div>

    <!-- Part4 -->
    <div class="section" id="part4">
      <h2>Part4: Bells & Whistles</h2>
      <!-- 等你补充 -->
    </div>

  </div>
</body>
</html>

